@page "/othello"
@inject IJSRuntime jsRuntime
@using mcts

<h3>Othello</h3>

<div id="game">
    @for (int i = 0; i < 64; i++)
    {
        int j = i;
        <div id="@i" class="cell" data-player="@GetPlayer(i)" data-valid-move="@GetIsValidMove(i)" @onclick="@((args) => MakeMove(j))"></div>
    }
</div>

@code {
    Othello game = new Othello();
    PlayerId[] cells;
    mcts.MonteCarloTreeSearchPlayer ai = new MonteCarloTreeSearchPlayer(1000);

    protected override async Task OnInitializedAsync()
    {
        await Prerender();
    }

    async Task Prerender()
    {
        cells = game.GetBoard();
        try
        {
            await jsRuntime.InvokeAsync<string>("console.log", game.LastPlayersTurn + ": valid move selected: " + game.DescribeLastMove());
        }
        catch
        {
            // who cares, we're just logging some stuff
        }
        StateHasChanged();
    }

    string GetPlayer(int i)
    {
        return cells[i].ToString();
    }

    string GetIsValidMove(int i)
    {
        return game.IsValidMove(1ul << i).ToString();
    }

    async void MakeMove(int i)
    {
        ulong move = 1ul << i;
        if (game.CurrentPlayersTurn == PlayerId.Player1 && game.IsValidMove(move))
        {
            await HumanMove(move);
            await AiMove();
            // TODO: need to skip players turns when they cannot go
        }
        else
        {
            await jsRuntime.InvokeAsync<string>("console.log", game.CurrentPlayersTurn + ": invalid move selected: " + i);
        }
    }

    async Task HumanMove(ulong move)
    {
        game = game.ApplyMove(move);
        await Prerender();
    }

    async Task AiMove()
    {
        game = (Othello)ai.MakeMove(game, game.ExpandSuccessors());
        await Prerender();
    }
}
